\section{Benchmarking}
\label{sec:benchmarking}


We present a set of experiments to evaluate the efficacy of the proposed modular code generation tool (\ourTool) with \simulink. 
In the first experiment, we select benchmarks that span across different application domains such as medical, physics, and industrial automation, to illustrate the \emph{diversity} of the proposed approach.
We then compare each of these benchmarks against \simulink in terms of execution time and maximum memory usage.
In the second experiment, we evaluate the \emph{scalability} of \ourTool and \simulink as the number of cells in the \ac{NHC} model increases. 


\subsection{Experimental set-up}
\label{sec:experimentalSetUp}
The following steps were considered in order to achieve a fair comparison between \ourTool and \simulink:

\begin{description}[\IEEEsetlabelwidth{Step Size}\IEEEusemathlabelsep]
	\item[\textbf{Solver}] To reflect the synchronous execution model, we used a discrete solver with a fixed step in \simulink, namely \texttt{ode1} (Forward Euler).
	
	\item[\textbf{Step Size}] For all benchmarks the step size in \simulink is fixed to $0.01$ milliseconds.
	The same step size is also used in \ourTool, $\delta = 0.01$ milliseconds.
	
	\item[\textbf{Time}] All benchmarks were simulated for $10$ seconds of simulation time.
	Based on a step size of $0.01$ milliseconds this translates to $1$ million ticks in \ourTool.
\end{description}

The experiments were evaluated using an Intel~i7-4790 processor with 8~GB RAM on Windows~7. 


\subsection{Diversity}

\begin{figure}[htbp]
	\centering
	\subfigure[Execution time (ms) \label{fig:executionTime}]{
		\input{./figures/executionTimeGraph}
	}
	\subfigure[Memory requirement (MB) \label{fig:memoryRequirement}]{
		\input{./figures/memoryRequirementGraph}
	}
	\caption{Comparison of the execution time (in ms) and memory requirement (in MB) between \simulink and \ourTool for the benchmarks in Table~\ref{tab:benchmarks}.}
	\label{fig:results}
\end{figure}

For the purposes of this experiment, we use the five benchmarks presented in Table~\ref{tab:benchmarks}.
The table also presents the number of locations (\#L) in each hybrid automata.
For example, $(2, 2, 2)$ denotes that the \acf{TTS} benchmark is described using three \acp{HA} each with two locations.
More details about the benchmarks and their implementation in \ourTool and \simulink are available online~\cite{githubBenchmarks}.

For all the benchmarks, the executable for the \simulink models are generated using the in-built Real-time Workshop\textsuperscript{\textregistered} C code generator.
Similarly, for \ourTool, we generate equivalent C code and compile to an executable using GCC.
The execution times and memory requirements of the generated executables are reported below and illustrated in Figure~\ref{fig:results}.

\textbf{Execution time:} 
Figure~\ref{fig:executionTime} shows that...

\textbf{Code size:}
Figure~\ref{fig:memoryRequirement} shows that...

On average, the code generated by \ourTool executes ?? times faster, while requiring ?? times less memory when compared to \simulink.

\input{./content/05_tableBenchmarks}


\subsection{Scalability}

\begin{figure}[htbp]
	\centering
	\input{./figures/scalabilityGraph}
	\caption{Scalability in  execution time of \simulink and \ourTool against number of cells}
	\label{fig:scalability}
\end{figure}

The purpose of the second experiment was to validate the scalability of \ourTool through the running example of the \ac{NHC} whilst comparing it to \simulink.
Code was generated for varying network sizes (33 cells, 66 cells, 99 cells, etc.) and the execution time recorded.
The experimental set-up was the same as described in Section~\ref{sec:experimentalSetUp}, ie. $1$ million ticks at a $0.01$ millisecond step size.

The most obvious feature of these results is that no data is recorded for \simulink for complexities greater than 297 cells. \simulink imposes an inbuilt requirement that the generated code use less than 2.1GB of memory and this discontinuity represents the point after which the memory requirement exceeds this limit\footnote{\simulink memory usage at 297 cells is 1.8GB}.

\begin{itemize}
	\item \ourTool has a smaller gradient
	\item \ourTool carries past this point that \simulink doesn't
	\item Point out the change in gradient around ~240 cells in \ourTool is due to cache size
	\item Mention the real time requirements for \ourTool vs \simulink
\end{itemize}