\section{Modular code generation}
\label{sec:codeGen}

In this section we present our approach for modular code generation from
a network of \acp{HIOA} as it is implemented in our tool, called
\ourTool.  An overview of the solution is presented in 
Figure~\ref{fig:overview}. Firstly, we present how each \ac{ODE} is converted 
to its numerical equivalent in Section~\ref{sec:converting-odes-into} followed 
by code generation for a single \ac{HIOA} through the use of a Mealy \ac{FSM} 
in Section~\ref{sec:backendCodeGeneration}.

\subsection{Converting the \acp{ODE} into equivalent witness functions}
\label{sec:converting-odes-into}

Given the \ac{ODE} for $\dot{v_x}$ in state $\mathbf{q_0}$ of the heart
node \ac{HIOA} defined in Figure~\ref{fig:heartCellHA} (reproduced in
Equation~(\ref{eq:ode})), the forward Euler method computes the next
value of $v_{x}$ (denoted $v'_{x}$) at discrete time instants, separated
by the so called time step $\delta$
($\delta \in \mathbb{R}^{+}$). The witness function for $v_{x}$
implementing the forward Euler method is shown in
Equation~(\ref{eq:euler_equiv}). This witness function evolves the
variable $v_{x}$ until some invariant condition $Inv$ on the location
holds. For the current example, Equation~(\ref{eq:euler_equiv}) evolves
$v_{x}$ \emph{iteratively} until the invariant condition on location
$\mathbf{q_{0}}$ ($v < V_{T}$) holds.  The initial value for $v_{x}$ is that 
from $Init$ in the \ac{HIOA} for the first time control enters $\mathbf{q_0}$ 
and the value from the previous transition's update thereafter.


\begin{equation}
  \dot{v_x} = C_{1} v_x
  \label{eq:ode}
\end{equation}

\begin{equation}
  v^\prime_x = v_x + \delta \times (C_{1} v_x)
  \label{eq:euler_equiv}
\end{equation}


This iterative evolution of the continuous variables at discrete points
in time is akin to transitions on a logical \emph{tick} of a
synchronous program~\cite{benveniste03}. A likeness that we will exploit when 
composing multiple \ac{HIOA} together in Section~\ref{sec:composition}.


\subsection{Backend code generation for a single \ac{HIOA}}
\label{sec:backendCodeGeneration}

\begin{figure}
  \centering
  \input{figures/cellFSM}
  \caption{\acf{FSM} of a heart node \label{fig:heartCellFSM}. We ignore
    the $\tau$ event in the \ac{FSM}, because it always evaluates to $true$.}
\end{figure}

In order to facilitate code generation, each \ac{HIOA} is transformed into a 
simple Mealy \ac{FSM} (such as that shown in Figure~\ref{fig:heartCellFSM}) 
where each iteration of the \ac{FSM} requires a transition be taken.  Two 
initial steps are performed: (1) for each location in the \ac{HIOA} there is a 
corresponding state in the \ac{FSM} of the same name and (2) for each 
inter-location edge $e$ in the \ac{HIOA} there is a corresponding transition $t$
between the same two states. Each transition $t$ has a condition equal to the 
input events of $e$ conjuncted with the conditions in $Jump(e)$, and output 
equal to the output events of $e$ combined with the updates present in 
$Jump(e)$.

In order to replicate the continuous evolution of variables within locations we 
create self transitions on each state in the \ac{FSM}. The invariant in $Inv$ 
from the initial \ac{HIOA} becomes the condition of the transition, and the 
witness functions for each of the \acs{ODE} described in 
Section~\ref{sec:converting-odes-into} become the output of the transition. 
However, to ensure that the generated \ac{FSM} does not ignore any controller 
inputs the self transition of each state is made to be of a lower priority 
than all inter-state transitions.  This is accomplished by changing the 
condition to be conjuncted with the negation of the disjunction of all 
conditions of egress transitions from the state, i.e. $Cond(self) \wedge \neg 
(Cond(trans_{0}) \vee \dots \vee Cond(trans_{n})$.  For location $\mathbf{q_0}$ 
in the \ac{HIOA} the invariant $v < V_{T}$ will become a self transition on 
state $\mathbf{q_0}$ in the \ac{FSM} with a condition of $v < V_{T} \wedge \neg 
(g(\vec{v_{I}}) \geq V_{T})$.  The final corresponding \ac{FSM} for the 
\ac{HIOA} from Figure~\ref{fig:heartCellHA} is shown in 
Figure~\ref{fig:heartCellFSM}.

The \acp{FSM} is then transformed into C code which contains an 
\emph{Initialisation Function} corresponding to the $Init$ of the \ac{HIOA} as 
well as the setting of the initial state, and a \emph{Run Function} which, 
given an existing state $l$ and values for all variables $X$ and events 
$\Sigma$, performs a single transition and updates any variables or events that 
may have changed.
