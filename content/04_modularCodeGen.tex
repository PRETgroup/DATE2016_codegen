\section{Modular code generation}
\label{sec:codeGen}

In this section we present our approach for modular code generation from
<<<<<<< HEAD
a network of \acp{SHIOA} as it is implemented in our tool, called
\ourTool. An overview of the solution is presented in
Figure~\ref{fig:overview}, with the first of the two steps being
outlined previously in Section~\ref{sec:SHA}, and the second step in
Section~\ref{sec:backendCodeGeneration} below. We first describe code
generation for a single \ac{SHIOA}, followed by the the modular linking
technique given a network of \acp{SHIOA}.
=======
a network of \acp{HIOA} as it is implemented in our tool, called
\ourTool.  An overview of the solution is presented in 
Figure~\ref{fig:overview}. Firstly, we present how each \ac{ODE} is converted 
to its numerical equivalent in Section~\ref{sec:converting-odes-into} followed 
by the abstraction of the generated code through the use of a Mealy \ac{FSM} in 
Section~\ref{sec:backendCodeGeneration}.

\subsection{Converting the \acp{ODE} into equivalent witness functions}
\label{sec:converting-odes-into}

Given the \ac{ODE} for $\dot{v_x}$ in state $\mathbf{q_0}$ of the heart
node \ac{HIOA} defined in Figure~\ref{fig:heartCellHA} (reproduced in
Equation~(\ref{eq:ode})), the forward Euler method computes the next
value of $v_{x}$ (denoted $v'_{x}$) at discrete time instants, separated
by the so called time step $\delta$
($\delta \in \mathbb{R}^{+}$). The witness function for $v_{x}$
implementing the forward Euler method is shown in
Equation~(\ref{eq:euler_equiv}). This witness function evolves the
variable $v_{x}$ until some invariant condition $Inv$ on the location
holds. For the current example, Equation~(\ref{eq:euler_equiv}) evolves
$v_{x}$ \emph{iteratively} until the invariant condition on location
$\mathbf{q_{0}}$ ($v < V_{T}$) holds.


\begin{equation}
  \dot{v_x} = C_{1} v_x
  \label{eq:ode}
\end{equation}

\begin{equation}
  v^\prime_x = v_x + \delta \times (C_{1} v_x)
  \label{eq:euler_equiv}
\end{equation}


This iterative evolution of the continuous variables at discrete points
in time is akin to transitions on a logical \emph{tick} of a
synchronous program~\cite{benveniste03}. A likeness that we will exploit when 
composing multiple \ac{HIOA} together in Section~\ref{sec:composition}.
>>>>>>> 7778523e6dabfdeca0d0390b21d0c9ec129ad2ac

\subsection{Backend code generation from a single \ac{SHIOA}}
\label{sec:backendCodeGeneration}

<<<<<<< HEAD
=======
Here we describe step $1$ of the compilation process from 
Figure~\ref{fig:overview}.

>>>>>>> 7778523e6dabfdeca0d0390b21d0c9ec129ad2ac
\begin{figure}
  \centering
  \input{figures/cellFSM}
  \caption{\acf{FSM} of a heart cell \label{fig:heartCellFSM}. We ignore
    the $\tau$ event in the \ac{FSM}, because it always evaluates to $true$.}
\end{figure}

In order to facilitate code generation, each \ac{HIOA} is transformed into a 
simple Mealy \ac{FSM} (such as that shown in Figure~\ref{fig:heartCellFSM}) 
where each iteration of the program requires a transition be taken.  Each 
inter-location edge $e$ corresponds to a transition between the same two states 
with condition equal to its input events $\wedge$ $Jump(e)$ and output equal to 
its output events $\wedge$ $Update(e)$ {\color{red} Where are Updates in the 
HIOA def?}.

In order to replicate the continuous evolution of variables within locations we 
create self transitions on each state in $Loc$, where the invariant in $Inv$ 
becomes the condition of the transition, and the witness functions for each of 
the \acs{ODE} described in Section~\ref{sec:converting-odes-into} become the 
output of the transition. However, to ensure that the generated \ac{FSM} does 
not ignore any controller inputs the self transition of each state must be of 
the lowest priority.  This is accomplished by changing the condition to be 
conjuncted with the negation of the disjunction of all conditions of egress 
transitions from the state, i.e. $Inv(l) \wedge \neg (Cond(trans_{0}) \vee 
\dots \vee Cond(trans_{n})$.  For example, in state $\mathbf{q_0}$ the 
invariant $v < V_{T}$ will become a self transition with a condition of $v < 
V_{T} \wedge \neg (g(\vec{v_{I}}) \geq V_{T})$ in the generated \ac{FSM}.

The final corresponding \ac{FSM} for the \ac{HIOA} from 
Figure~\ref{fig:heartCellHA} is shown in Figure~\ref{fig:heartCellFSM}.

Each of these \acp{FSM} are then transformed into C code which contains an 
\emph{Initialisation Function} corresponding to the $Init$ of the \ac{FSM}, and 
a \emph{Run Function} which, given an existing state $l$ and values for all 
variables $X$ and events $\Sigma$, performs a single transition and updates any 
variables or events that may have changed.
