\section{Modular code generation}
\label{sec:codeGen}

In this section we present our approach for modular code generation from
a network of \acp{HIOA} as it is implemented in our tool, called
\ourTool.  An overview of the solution is presented in
Figure~\ref{fig:overview}, with the first of the two steps being
outlined previously in Section~\ref{sec:SHA}, and the second step in
Section~\ref{sec:backendCodeGeneration} below.


%Every \ac{HIOA} is converted into a so called \ac{SHIOA}, where the ODEs
%in the flow predicates are replaced by their equivalent witness
%functions $Switness$. The witness function computes the evolution of the
%continuous variables using the forward Euler approach with a
%\emph{constant} step size. Before giving the formal definition of the
%\ac{SHIOA} and describing the compilation procedure, we present the
%procedure to convert each ODE into its equivalent witness function, this
%is the step 1 (c.f. Figure~\ref{fig:overview}) in our modular code
%generation framework.

\subsection{Converting the ODEs into equivalent witness functions}
\label{sec:converting-odes-into}

Given the \ac{ODE} for $\dot{v_x}$ in state $\mathbf{q_1}$ of the heart
node \ac{HIOA} defined in Figure~\ref{fig:heartCellHA} (reproduced in
Equation~(\ref{eq:ode})), the forward Euler method computes the next
value of $v_{x}$ denoted $v'_{x}$ at discrete time instants, separated
by the so called time step denoted by $\delta$
($\delta \in \mathbb{R}^{+}$). The witness function for $v_{x}$
implementing the Euler function is shown in
Equation~(\ref{eq:euler_equiv}). This witness function evolves the
variable $v_{x}$ until some invariant condition $Inv$ on the location
holds. For the current example, Equation~(\ref{eq:euler_equiv}) evolves
$v_{x}$ \emph{iteratively} until the invariant condition on location
$\mathbf{q_{1}}$ holds.

This iterative evolution of the continuous variables at discrete points
in time is akin to the transitions of logical \emph{tick} of a
synchronous program~\cite{benveniste03}. Hence, we term the automata
resulting after replacing every ODE with its equivalent witness function
a \acf{SHIOA}.


\begin{equation}
\dot{v_x} = C_{4} v_x + C_{7} g(\vec{v_{I}})
\label{eq:ode}
\end{equation}

\begin{equation}
v^\prime_x = v_x + \delta \times (C_{4} v_x + C_{7} g(\vec{v_{I}}))
\label{eq:euler_equiv}
\end{equation}


\subsection{Backend code generation}
\label{sec:backendCodeGeneration}

Here we describe step $2$ of the compilation process from
Figure~\ref{fig:overview}. Once a network of \acp{SHIOA} has been
created, code needs to be generated to implement the functionality of
each \ac{SHIOA}.

\begin{figure}
  \centering
  \input{figures/cellFSM}
  \caption{\acf{FSM} of a heart cell \label{fig:heartCellFSM}. We ignore
    the $\tau$ event in the FSM, because it always evaluates to $true$.}
\end{figure}

In order to facilitate code generation, each \ac{SHIOA} is transformed
into a simple Mealy \ac{FSM} (such as that shown in
Figure~\ref{fig:heartCellFSM}) where each step of the program requires a
transition be taken.  This process involves creating self loops on each
state in $Loc$, where the invariant in $Inv$ becomes the guard of the
transition, and the \acs{ODE} in $Switness$ become the outputs of the
transition.  The corresponding \ac{FSM} for the \ac{SHIOA} from
Figure~\ref{fig:heartCellSHA} is shown in Figure~\ref{fig:heartCellFSM}.

Each of these \acp{FSM} are then transformed into C code which contains
an \emph{Initialisation Function} corresponding to the $Init$ of the
\ac{FSM}, and a \emph{Run Function} which, given an existing state,
performs a single transition and updates any signals that may have
changed.



